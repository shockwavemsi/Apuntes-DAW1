# Cosas a reforzar

- **GENERATED BY DEFAULT AS IDENTITY:** Utilizada para generar valores automáticamente en columnas de tipo identidad en tablas.
- **.NEXT VAL:** Utilizando una secuencia para generar valor únicos. Útil para claves primarias
- **SYSDATE:** Función que devuelve la fecha y hora del sistema en el momento de una ejecución.
- **CHECK IN:** Utilizada para restringir un formato a los valores de una columna.
- **CURSOR:** Utilizada para manejar conjuntos de datos obtenidos de una sentencia SQL dentro de PL/SQL.
- **FETCH / CLOSE:** Se usa con `CURSORES`. 
	- **FETCH:** Recupera la siguiente fila de datos
	- **CLOSE:** Libera los recursos asociados al cursor cuando ya no los necesita.
- **LOOP:** Utilizada para repetir varias acciones hasta que cumpla una condición (es un bucle).
- **%NOTFOUND :** Se usa en un `FETCH`, `%NOTFOUND` se utiliza para verificar *si no se encontró un dato* ó *si se agotaron los registros* en un bucle.

# Temas expandidos:

1. **GENERATED BY DEFAULT AS IDENTITY**

La usaremos para crear una columna con valores automáticos de identidad (`ID`).

```PLSQL
CREATE TABLE empleados (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(50)
);
```

Cada vez que insertemos un nuevo registro, `id` se generará automaticamente.

2. **.NEXTVAL**

Utilizando una secuencia para generar valor únicos.

```PLSQL
-- Crear la secuencia para generar valores únicos
CREATE SEQUENCE cliente_seq
	START WITH 100 -- Comenzamos en 100
	INCREMENT BY 10; -- Se incrementa en 10 cada vez

-- Insertamos registros con .NEXTVAL
INSERT INTO clientes(id,nombre) VALUES(cliente_seq.NEXTVAL,'Juan');
INSERT INTO clientes(id,nombre) VALUES(cliente_seq.NEXTVAL,'María');
INSERT INTO clientes(id,nombre) VALUES(cliente_seq.NEXTVAL,'Luis');

-- Consultamos los datos insertados
SELECT * FROM;
```

Aquí, `cliente_seq.NEXTVAL` obtiene el siguiente valor de la secuencia `cliente_seq` en cada inserción, creando varios `id` únicos.

3. **SYSDATE**

Para insertar la fecha y hora actual.

```PLSQL
INSERT INTO registro (fecha) VALUES (SYSDATE);
```

`SYSDATE` almacena la fecha del sistema en el momento de la ejecución.

4. **CHECK IN**

Restringe mediante condiciones los valores de una columna.

```PLSQL
CREATE TABLE productos (
    id NUMBER PRIMARY KEY,
    categoria VARCHAR2(20) CHECK (categoria IN ('Electronica', 'Ropa', 'Comida'))
);
```

Solo permite valore específicos (`Electronica`,`Ropa`,`Comida`) en la columna `categoria`.

5. **CURSOR**

Cursor para recorrer registros:

```PLSQL
DECLARE 
    CURSOR c_empleados IS SELECT nombre FROM empleados;
    v_nombre empleados.nombre%TYPE;
BEGIN
    OPEN c_empleados;
    LOOP
        FETCH c_empleados INTO v_nombre;
        EXIT WHEN c_empleados%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_nombre);
    END LOOP;
    CLOSE c_empleados;
END;
```

Este cursor recorre los nombres de los empleados y los imprime.

6. **FETCH / CLOSE**

Recupera y cierra el cursor

```PLSQL
DECLARE 
	-- Declaramos el cursor 
    CURSOR c_empleados IS SELECT nombre FROM empleados;
    -- Declaramos un variable que sera del mismo tipo de "nombre".
    v_nombre empleados.nombre%TYPE;
BEGIN
    OPEN c_empleados;
    FETCH c_empleados INTO v_nombre;
    DBMS_OUTPUT.PUT_LINE(v_nombre);
    CLOSE c_empleados;
END;
```

Aquí obtenemos un solo nombre y cerramos el cursor inmediatamente. 

7. **LOOP**

Utilizado para hacer bucles.

```PLSQL
DECLARE
	-- Declaramos un varible v_contador de tipo entero, con el valor 1.
    v_contador NUMBER := 1;
BEGIN
	-- Aquí se inicia el bucle
    LOOP
        DBMS_OUTPUT.PUT_LINE('Iteración: ' || v_contador);
        v_contador := v_contador + 1;
        --Declaramos una condición para salir del bucle
        EXIT WHEN v_contador > 5;
    --Aqui el final del buble
    END LOOP;
END;
```

Este bucle imprime cinco iteraciones cada una, e incrementa en 1 a 1 la variable `v_contador`.

8. **%NOTFOUND**

Se usa en un `FETCH`, `%NOTFOUND` se utiliza para verificar *si no se encontró un dato* ó *si se agotaron los registros* en un bucle.

```PLSQL
DECLARE 
    CURSOR c_empleados IS SELECT nombre FROM empleados;
    v_nombre empleados.nombre%TYPE;
BEGIN
    OPEN c_empleados;
    LOOP
        FETCH c_empleados INTO v_nombre;
        EXIT WHEN c_empleados%NOTFOUND; -- Salimos del bucle cuando no hay más filas
        DBMS_OUTPUT.PUT_LINE('Empleado: ' || v_nombre);
    END LOOP;
    CLOSE c_empleados;
END;
```

### Explicación del código

1. **Definimos un cursor** `c_empleados` que selecciona nombres de la tabla `empleados`.
    
2. **Abrimos el cursor con** `OPEN`.
    
3. **Usamos un bucle** `LOOP` para obtener cada fila con `FETCH`.
    
4. **Verificamos** `c_empleados%NOTFOUND`:
    
    - Si **hay datos**, continúa el bucle.
        
    - Si **no hay más registros**, se activa `%NOTFOUND` y el bucle **finaliza** con `EXIT`.

# Ejercicios para repasar

### **Ejercicio 1: Identidad automática (**`GENERATED BY DEFAULT AS IDENTITY`**)**

Crea una tabla llamada `productos` con una columna `id_producto` que se genere automáticamente como identidad. Luego, inserta algunos registros en la tabla sin proporcionar el `id_producto`.

```PLSQL
-- Creación de la tabla productos
CREATE TABLE productos(
	id_producto NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	nombre VARCHAR2(50)
);

-- Insertamos datos a la tabla productos
INSERT INTO productos(nombre) VALUES ('Xiaomi');
INSERT INTO productos(nombre) VALUES ('Redmagic');

-- Comprobamos los datos de la tabla
SELECT * FROM productos;
```

### **Ejercicio 2: Usando** `NEXTVAL` **en una secuencia**

1. Crea una secuencia llamada `SEQ_PEDIDOS` que comience en 100 y aumente de 10 en 10.
    
2. Usa la secuencia para insertar 5 pedidos en una tabla `pedidos`.

```PLSQL
-- Creación de la secuencia
CREATE SEQUENCE SEQ_PEDIDOS
	START WITH 100
	INCREMENT BY 10;

-- Insercción de los datos con la secuencia
INSERT INTO pedidos(id_producto) VALUES (SEQ_PEDIDOS.NEXTVAL);
INSERT INTO pedidos(id_producto) VALUES (SEQ_PEDIDOS.NEXTVAL);
INSERT INTO pedidos(id_producto) VALUES (SEQ_PEDIDOS.NEXTVAL);
INSERT INTO pedidos(id_producto) VALUES (SEQ_PEDIDOS.NEXTVAL);
INSERT INTO pedidos(id_producto) VALUES (SEQ_PEDIDOS.NEXTVAL);

--Comprobamos los datos de la tabla
SELECT * FROM productos;
```

### **Ejercicio 3: Registro con fecha (**`SYSDATE`**)**

Diseña una tabla `logs` que almacene eventos con la fecha y hora exacta en que ocurrieron. Luego, inserta varios eventos utilizando `SYSDATE`.

```PLSQL
-- Creación de la tabla
CREATE TABLE logs(
	fecha DATE
);

-- Insertamos la fecha actual en el campo fecha.
INSERT INTO logs(fecha) VALUES (SYSDATE);
```


### **Ejercicio 4: Restricciones (**`CHECK IN`**)**

Define una tabla `usuarios` que contenga una columna `rol` con una restricción que solo permita los valores `'ADMIN'`, `'USER'` o `'GUEST'`. Intenta insertar valores válidos e inválidos para comprobar el funcionamiento del `CHECK`.

```PLSQL
-- Creamos la tabla usuarios con la restricciones en el campo "rol"
CREATE TABLE usuarios(
	rol VARCHAR2(5) CHECK (rol in ('ADMIN','USER','GUEST')),
	nombre VARCHAR2(50)
);
-- Insertamos los datos (como son correctos no dara problemas).
INSERT INTO usuarios(rol,nombre) VALUES ('ADMIN','Jaren Andre');

-- Insertamos los datos (esto devolverá un error porque no esta permitido el rol "SUPERADMIN").
INSERT INTO usuarios(rol,nombre) VALUES ('SUPERADMIN','Eliana');
```

### **Ejercicio 5: Cursores (**`CURSOR`**,** `FETCH`**,** `CLOSE`**)**

1. Crea un cursor que recupere todos los nombres de una tabla `clientes`.
    
2. Usa un `LOOP` para imprimir cada nombre en la consola con `DBMS_OUTPUT.PUT_LINE`.

```PLSQL
DECLARE
	-- Declaramos un cursor(con una sentencia SQL)
	CURSOR r_nombre IS SELECT nombre FROM clientes;
	-- Declaramos una variable(con el mismo tipo que devolvera el cursor).
	nombres r_nombre.nombre%TYPE;
BEGIN
	-- Abrimos el cursor
	OPEN r_nombre; 
	--Creamos un bucle
	LOOP
		--Lo datos que devuelve el cursor los guardamos en al variable "nombres".
		FETCH r_nombre INTO nombres;
		EXIT WHEN r_nombre%NOTFOUND; -- Salimos del bucle cuando no registre más filas.
		DBMS.OUTPUT_LINE.PUT_LINE('Empleado ' || nombres || ' :'):
	END LOOP;
	-- Cerramos el cursor
	CLOSE r_nombre;
END;
```
    

### **Ejercicio 6: Bucles (**`LOOP`**)**

Escribe un procedimiento que genere números del 1 al 10 utilizando un bucle `LOOP` e imprima cada número en pantalla.

```PLSQL
DECLARE
	n NUMBER(2) :=0;
BEGIN
	LOOP
		n := n+1;
		DBMS_OUTPUT.PUT_LINE (n);
		EXIT WHEN n = 10; -- Salimos del bucle cuando n sea igual a "10".
	END LOOP; 
END;
```

### **Ejercicio 7: Uso de** `%NOTFOUND`

1. Crea un cursor que seleccione todos los productos de la tabla `inventario`.
    
2. Usa `%NOTFOUND` para salir del `LOOP` cuando ya no haya más registros.

```PLSQL
DECLARE
	CURSOR cursor_productos IS SELECT productos FROM inventario;
	producto inventario.productos%TYPE;
BEGIN
	OPEN cursor_productos;
		LOOP
			FETCH cursor_productos INTO producto;
			EXIT WHEN cursor_productos%NOTFOUND;
		END LOOP;
	CLOSE cursor_productos;
END;

```